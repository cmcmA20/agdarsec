<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SExp</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="SExp.html" class="Module">SExp</a> <a id="13" class="Keyword">where</a>

<a id="20" class="Keyword">import</a> <a id="27" href="Level.html" class="Module">Level</a>
<a id="33" class="Keyword">open</a> <a id="38" class="Keyword">import</a> <a id="45" href="Level.Bounded.html" class="Module">Level.Bounded</a> <a id="59" class="Keyword">using</a> <a id="65" class="Symbol">(</a><a id="66" href="Level.Bounded.html#931" class="Field">theSet</a><a id="72" class="Symbol">;</a> <a id="74" href="Level.Bounded.html#1072" class="Function Operator">[_]</a><a id="77" class="Symbol">)</a>
<a id="79" class="Keyword">open</a> <a id="84" class="Keyword">import</a> <a id="91" href="Data.Char.Base.html" class="Module">Data.Char.Base</a>
<a id="106" class="Keyword">open</a> <a id="111" class="Keyword">import</a> <a id="118" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="135" class="Symbol">as</a> <a id="138" class="Module">String</a> <a id="145" class="Keyword">using</a> <a id="151" class="Symbol">(</a><a id="152" href="Agda.Builtin.String.html#274" class="Postulate">String</a><a id="158" class="Symbol">)</a>

<a id="161" class="Keyword">data</a> <a id="SExp"></a><a id="166" href="SExp.html#166" class="Datatype">SExp</a> <a id="171" class="Symbol">:</a> <a id="173" class="PrimitiveType">Set</a> <a id="177" class="Keyword">where</a>
  <a id="SExp.Atom"></a><a id="185" href="SExp.html#185" class="InductiveConstructor">Atom</a> <a id="190" class="Symbol">:</a> <a id="192" href="Agda.Builtin.String.html#274" class="Postulate">String</a> <a id="199" class="Symbol">‚Üí</a> <a id="201" href="SExp.html#166" class="Datatype">SExp</a>
  <a id="SExp.Pair"></a><a id="208" href="SExp.html#208" class="InductiveConstructor">Pair</a> <a id="213" class="Symbol">:</a> <a id="215" href="SExp.html#166" class="Datatype">SExp</a> <a id="220" class="Symbol">‚Üí</a> <a id="222" href="SExp.html#166" class="Datatype">SExp</a> <a id="227" class="Symbol">‚Üí</a> <a id="229" href="SExp.html#166" class="Datatype">SExp</a>

<a id="235" class="Keyword">open</a> <a id="240" class="Keyword">import</a> <a id="247" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="262" class="Keyword">open</a> <a id="267" class="Keyword">import</a> <a id="274" href="Data.List.Sized.Interface.html" class="Module">Data.List.Sized.Interface</a>
<a id="300" class="Keyword">open</a> <a id="305" class="Keyword">import</a> <a id="312" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="331" class="Symbol">as</a> <a id="334" class="Module">List‚Å∫</a> <a id="340" class="Keyword">using</a> <a id="346" class="Symbol">(</a><a id="347" href="Data.List.NonEmpty.html#1318" class="Record">List‚Å∫</a><a id="352" class="Symbol">)</a>
<a id="354" class="Keyword">open</a> <a id="359" class="Keyword">import</a> <a id="366" href="Data.Maybe.html" class="Module">Data.Maybe</a>
<a id="377" class="Keyword">open</a> <a id="382" class="Keyword">import</a> <a id="389" href="Data.Product.html" class="Module">Data.Product</a>
<a id="402" class="Keyword">open</a> <a id="407" class="Keyword">import</a> <a id="414" href="Data.Subset.html" class="Module">Data.Subset</a>
<a id="426" class="Keyword">open</a> <a id="431" class="Keyword">import</a> <a id="438" href="Function.Base.html" class="Module">Function.Base</a>
<a id="452" class="Keyword">open</a> <a id="457" class="Keyword">import</a> <a id="464" href="Induction.Nat.Strong.html" class="Module">Induction.Nat.Strong</a>
<a id="485" class="Keyword">open</a> <a id="490" class="Keyword">import</a> <a id="497" href="Relation.Unary.html" class="Module">Relation.Unary</a> <a id="512" class="Keyword">using</a> <a id="518" class="Symbol">(</a><a id="519" href="Relation.Unary.html#3359" class="Function">IUniversal</a> <a id="530" class="Symbol">;</a> <a id="532" href="Relation.Unary.html#4338" class="Function Operator">_‚áí_</a><a id="535" class="Symbol">)</a>
<a id="537" class="Keyword">open</a> <a id="542" class="Keyword">import</a> <a id="549" href="Relation.Binary.PropositionalEquality.Decidable.html" class="Module">Relation.Binary.PropositionalEquality.Decidable</a>

<a id="598" class="Keyword">open</a> <a id="603" class="Keyword">import</a> <a id="610" href="Text.Parser.Types.html" class="Module">Text.Parser.Types</a>
<a id="628" class="Keyword">open</a> <a id="633" class="Keyword">import</a> <a id="640" href="Text.Parser.Combinators.html" class="Module">Text.Parser.Combinators</a>
<a id="664" class="Keyword">open</a> <a id="669" class="Keyword">import</a> <a id="676" href="Text.Parser.Combinators.Char.html" class="Module">Text.Parser.Combinators.Char</a>

<a id="706" class="Keyword">module</a> <a id="713" href="SExp.html#713" class="Module">_</a> <a id="715" class="Symbol">{</a><a id="716" href="SExp.html#716" class="Bound">l</a><a id="717" class="Symbol">}</a> <a id="719" class="Symbol">(</a><a id="720" href="SExp.html#720" class="Bound">P</a> <a id="722" class="Symbol">:</a> <a id="724" href="Text.Parser.Types.html#476" class="Record">Parameters</a> <a id="735" href="SExp.html#716" class="Bound">l</a><a id="736" class="Symbol">)</a> <a id="738" class="Symbol">(</a><a id="739" class="Keyword">open</a> <a id="744" href="Text.Parser.Types.html#476" class="Module">Parameters</a> <a id="755" href="SExp.html#720" class="Bound">P</a><a id="756" class="Symbol">)</a>
         <a id="767" class="Symbol">{{</a><a id="769" href="SExp.html#769" class="Bound">ùïä</a> <a id="771" class="Symbol">:</a> <a id="773" href="Data.List.Sized.Interface.html#393" class="Record">Sized</a> <a id="779" href="Text.Parser.Types.html#572" class="Field">Tok</a> <a id="783" href="Text.Parser.Types.html#628" class="Field">Toks</a><a id="787" class="Symbol">}}</a>
         <a id="799" class="Symbol">{{</a><a id="801" href="SExp.html#801" class="Bound">ùïÑ</a> <a id="803" class="Symbol">:</a> <a id="805" href="Category.Monad.html#734" class="Function">RawMonadPlus</a> <a id="818" href="Text.Parser.Types.html#678" class="Field">M</a><a id="819" class="Symbol">}}</a>
         <a id="831" class="Symbol">{{</a><a id="833" href="SExp.html#833" class="Bound">ùîª</a> <a id="835" class="Symbol">:</a> <a id="837" href="Relation.Binary.PropositionalEquality.Decidable.Core.html#222" class="Record">DecidableEquality</a> <a id="855" class="Symbol">(</a><a id="856" href="Level.Bounded.html#931" class="Field">theSet</a> <a id="863" href="Text.Parser.Types.html#572" class="Field">Tok</a><a id="866" class="Symbol">)}}</a>
         <a id="879" class="Symbol">{{</a><a id="881" href="SExp.html#881" class="Bound">‚ÑÇ</a> <a id="883" class="Symbol">:</a> <a id="885" href="Data.Subset.html#108" class="Record">Subset</a> <a id="892" href="Agda.Builtin.Char.html#227" class="Postulate">Char</a> <a id="897" class="Symbol">(</a><a id="898" href="Level.Bounded.html#931" class="Field">theSet</a> <a id="905" href="Text.Parser.Types.html#572" class="Field">Tok</a><a id="908" class="Symbol">)}}</a>
         <a id="921" class="Symbol">{{</a><a id="923" href="SExp.html#923" class="Bound">‚ÑÇ‚Ä≤</a> <a id="926" class="Symbol">:</a> <a id="928" href="Data.Subset.html#108" class="Record">Subset</a> <a id="935" class="Symbol">(</a><a id="936" href="Level.Bounded.html#931" class="Field">theSet</a> <a id="943" href="Text.Parser.Types.html#572" class="Field">Tok</a><a id="946" class="Symbol">)</a> <a id="948" href="Agda.Builtin.Char.html#227" class="Postulate">Char</a><a id="952" class="Symbol">}}</a>
         <a id="964" class="Keyword">where</a>

  <a id="973" href="SExp.html#973" class="Function">sexp</a> <a id="978" class="Symbol">:</a> <a id="980" href="Relation.Unary.html#3359" class="Function">‚àÄ[</a> <a id="983" href="Text.Parser.Types.html#1406" class="Record">Parser</a> <a id="990" href="SExp.html#720" class="Bound">P</a> <a id="992" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="994" href="SExp.html#166" class="Datatype">SExp</a> <a id="999" href="Level.Bounded.html#1072" class="Function Operator">]</a> <a id="1001" href="Relation.Unary.html#3359" class="Function">]</a>
  <a id="1005" href="SExp.html#973" class="Function">sexp</a> <a id="1010" class="Symbol">=</a>
    <a id="1016" class="Comment">-- SExp is an inductive type so we build the parser as a fixpoint</a>
    <a id="1086" href="Induction.Nat.Strong.html#1188" class="Function">fix</a> <a id="1090" class="Symbol">(</a><a id="1091" href="Text.Parser.Types.html#1406" class="Record">Parser</a> <a id="1098" href="SExp.html#720" class="Bound">P</a> <a id="1100" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="1102" href="SExp.html#166" class="Datatype">SExp</a> <a id="1107" href="Level.Bounded.html#1072" class="Function Operator">]</a><a id="1108" class="Symbol">)</a> <a id="1110" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="1112" class="Symbol">Œª</a> <a id="1114" href="SExp.html#1114" class="Bound">rec</a> <a id="1118" class="Symbol">‚Üí</a>
        <a id="1128" class="Comment">-- First we have atoms. Assuming we have already consumed the leading space, an</a>
        <a id="1216" class="Comment">-- atom is just a non empty list of alphabetical characters.</a>

        <a id="1286" class="Comment">-- We use `&lt;$&gt;` to turn that back into a string and apply the `Atom` constructor.</a>
    <a id="1372" class="Keyword">let</a> <a id="1376" href="SExp.html#1376" class="Bound">atom</a> <a id="1381" class="Symbol">=</a> <a id="1383" href="SExp.html#185" class="InductiveConstructor">Atom</a> <a id="1388" href="Function.Base.html#1031" class="Function Operator">‚àò</a> <a id="1390" href="Data.String.Base.html#1546" class="Primitive">String.fromList</a> <a id="1406" href="Function.Base.html#1031" class="Function Operator">‚àò</a> <a id="1408" href="Data.List.NonEmpty.html#1760" class="Function">List‚Å∫.toList</a> <a id="1421" href="Function.Base.html#1031" class="Function Operator">‚àò</a> <a id="1423" href="Data.List.NonEmpty.html#2292" class="Function">List‚Å∫.map</a> <a id="1433" class="Symbol">(</a><a id="1434" href="Data.Subset.html#173" class="Field">into</a> <a id="1439" href="SExp.html#923" class="Bound">‚ÑÇ‚Ä≤</a><a id="1441" class="Symbol">)</a>
               <a id="1458" href="Text.Parser.Combinators.html#2989" class="Function Operator">&lt;$&gt;</a> <a id="1462" href="Text.Parser.Combinators.html#9377" class="Function">list‚Å∫</a> <a id="1468" href="Text.Parser.Combinators.Char.html#2207" class="Function">alpha</a>

        <a id="1483" class="Comment">-- Then we have subexpressions. Here we have to be a bit careful: we can have both</a>
        <a id="1574" class="Comment">-- * a sexp with additional parentheses √† la `(e)`</a>
        <a id="1633" class="Comment">-- * pairing constructs √† la `(e f)`</a>

        <a id="1679" class="Comment">-- In both cases they are surrounded by parentheses so we use `parens` and then we</a>
        <a id="1770" class="Comment">-- 1. unconditionally parse a subexpression thanks to `rec` introduced by the fixpoint earlier</a>
        <a id="1873" class="Comment">-- 2. _potentially_ consume a second subexpression (the `?`-tagged combinators are variants</a>
        <a id="1973" class="Comment">--    that are allowed to fail on the side the question mark is on).</a>

        <a id="2051" class="Comment">-- I give a bit more details about `lift` and `box` below.</a>
        <a id="2118" class="Comment">-- As for the previous case we use `&lt;$&gt;` to massage the result into a `SExp`.</a>
        <a id="2204" href="SExp.html#2204" class="Bound">sexp</a> <a id="2209" class="Symbol">=</a> <a id="2211" class="Symbol">(Œª</a> <a id="2214" class="Symbol">(</a><a id="2215" href="SExp.html#2215" class="Bound">a</a> <a id="2217" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2219" href="SExp.html#2219" class="Bound">mb</a><a id="2221" class="Symbol">)</a> <a id="2223" class="Symbol">‚Üí</a> <a id="2225" href="Data.Maybe.Base.html#1381" class="Function">maybe</a> <a id="2231" class="Symbol">(</a><a id="2232" href="SExp.html#208" class="InductiveConstructor">Pair</a> <a id="2237" href="SExp.html#2215" class="Bound">a</a><a id="2238" class="Symbol">)</a> <a id="2240" href="SExp.html#2215" class="Bound">a</a> <a id="2242" href="SExp.html#2219" class="Bound">mb</a><a id="2244" class="Symbol">)</a>
               <a id="2261" href="Text.Parser.Combinators.html#2989" class="Function Operator">&lt;$&gt;</a> <a id="2265" href="Text.Parser.Combinators.Char.html#1653" class="Function">parens</a> <a id="2272" class="Symbol">(</a><a id="2273" href="Text.Parser.Combinators.html#2496" class="Function">lift2</a> <a id="2279" class="Symbol">(Œª</a> <a id="2282" href="SExp.html#2282" class="Bound">p</a> <a id="2284" href="SExp.html#2284" class="Bound">q</a> <a id="2286" class="Symbol">‚Üí</a> <a id="2288" class="Symbol">(</a><a id="2289" href="Text.Parser.Combinators.Char.html#1350" class="Function">spaces</a> <a id="2296" href="Text.Parser.Combinators.html#6065" class="Function Operator">?&amp;&gt;</a> <a id="2300" href="SExp.html#2282" class="Bound">p</a> <a id="2302" href="Text.Parser.Combinators.html#5520" class="Function Operator">&lt;&amp;?</a> <a id="2306" href="Text.Parser.Combinators.html#2197" class="Function">box</a> <a id="2310" href="Text.Parser.Combinators.Char.html#1350" class="Function">spaces</a><a id="2316" class="Symbol">)</a> <a id="2318" href="Text.Parser.Combinators.html#5423" class="Function Operator">&lt;&amp;?&gt;</a> <a id="2323" href="Text.Parser.Combinators.html#2197" class="Function">box</a> <a id="2327" class="Symbol">(</a><a id="2328" href="SExp.html#2284" class="Bound">q</a> <a id="2330" href="Text.Parser.Combinators.html#5520" class="Function Operator">&lt;&amp;?</a> <a id="2334" href="Text.Parser.Combinators.html#2197" class="Function">box</a> <a id="2338" href="Text.Parser.Combinators.Char.html#1350" class="Function">spaces</a><a id="2344" class="Symbol">))</a>
                                 <a id="2380" href="SExp.html#1114" class="Bound">rec</a>
                                 <a id="2417" href="SExp.html#1114" class="Bound">rec</a><a id="2420" class="Symbol">)</a>
     <a id="2427" class="Keyword">in</a>

     <a id="2436" class="Comment">-- Finally we can put the two things together by using a simple disjunction</a>
     <a id="2517" href="SExp.html#1376" class="Bound">atom</a> <a id="2522" href="Text.Parser.Combinators.html#2335" class="Function Operator">&lt;|&gt;</a> <a id="2526" href="SExp.html#2204" class="Bound">sexp</a>


        <a id="2541" class="Comment">-- `lift`:</a>
        <a id="2560" class="Comment">-- parens is guaranteed to consume some of its input before calling its argument so</a>
        <a id="2652" class="Comment">-- the argument is guarded. We are however not making a direct call to `rec` in a guarded</a>
        <a id="2750" class="Comment">-- position: we are taking a (potentially failing) pairing of two sub-parsers, potentially</a>
        <a id="2849" class="Comment">-- eating some space, etc. So we use `lift2` as a way to distribute the proof that we are in</a>
        <a id="2950" class="Comment">-- a guarded position to the key elements that need it.</a>

        <a id="3015" class="Comment">-- `box`:</a>
        <a id="3033" class="Comment">-- sometimes on the other hand we have a guarded call but do not actually care. We can use</a>
        <a id="3132" class="Comment">-- `box` to discard the proof and use a normal parser in that guarded position.</a>


  <a id="3216" class="Comment">-- The full parser is obtained by disregarding spaces before &amp; after the expression</a>
  <a id="3302" href="SExp.html#3302" class="Function">SEXP</a> <a id="3307" class="Symbol">:</a> <a id="3309" href="Relation.Unary.html#3359" class="Function">‚àÄ[</a> <a id="3312" href="Text.Parser.Types.html#1406" class="Record">Parser</a> <a id="3319" href="SExp.html#720" class="Bound">P</a> <a id="3321" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="3323" href="SExp.html#166" class="Datatype">SExp</a> <a id="3328" href="Level.Bounded.html#1072" class="Function Operator">]</a> <a id="3330" href="Relation.Unary.html#3359" class="Function">]</a>
  <a id="3334" href="SExp.html#3302" class="Function">SEXP</a> <a id="3339" class="Symbol">=</a> <a id="3341" href="Text.Parser.Combinators.Char.html#1350" class="Function">spaces</a> <a id="3348" href="Text.Parser.Combinators.html#6065" class="Function Operator">?&amp;&gt;</a> <a id="3352" href="SExp.html#973" class="Function">sexp</a> <a id="3357" href="Text.Parser.Combinators.html#5520" class="Function Operator">&lt;&amp;?</a> <a id="3361" href="Text.Parser.Combinators.html#2197" class="Function">box</a> <a id="3365" href="Text.Parser.Combinators.Char.html#1350" class="Function">spaces</a>

<a id="3373" class="Keyword">open</a> <a id="3378" class="Keyword">import</a> <a id="3385" href="Base.html" class="Module">Base</a> <a id="3390" href="Level.html#360" class="Primitive">Level.zero</a>

<a id="3402" class="Comment">-- And we can run the thing on a test (which is very convenient when refactoring grammars!..):</a>
<a id="3497" href="SExp.html#3497" class="Function">_</a> <a id="3499" class="Symbol">:</a> <a id="3501" class="String">&quot;((  this    is)
      ((a (  pair based))
          ((S)(expression  ))))   &quot;</a> <a id="3580" href="Base.html#3127" class="Function Operator">‚àà</a> <a id="3582" href="SExp.html#3302" class="Function">SEXP</a> <a id="3587" href="Text.Parser.Monad.html#4530" class="Function">chars</a>
<a id="3593" class="Symbol">_</a> <a id="3595" class="Symbol">=</a> <a id="3597" href="SExp.html#208" class="InductiveConstructor">Pair</a> <a id="3602" class="Symbol">(</a><a id="3603" href="SExp.html#208" class="InductiveConstructor">Pair</a> <a id="3608" class="Symbol">(</a><a id="3609" href="SExp.html#185" class="InductiveConstructor">Atom</a> <a id="3614" class="String">&quot;this&quot;</a><a id="3620" class="Symbol">)</a> <a id="3622" class="Symbol">(</a><a id="3623" href="SExp.html#185" class="InductiveConstructor">Atom</a> <a id="3628" class="String">&quot;is&quot;</a><a id="3632" class="Symbol">))</a>
         <a id="3644" class="Symbol">(</a><a id="3645" href="SExp.html#208" class="InductiveConstructor">Pair</a> <a id="3650" class="Symbol">(</a><a id="3651" href="SExp.html#208" class="InductiveConstructor">Pair</a> <a id="3656" class="Symbol">(</a><a id="3657" href="SExp.html#185" class="InductiveConstructor">Atom</a> <a id="3662" class="String">&quot;a&quot;</a><a id="3665" class="Symbol">)</a>
                     <a id="3688" class="Symbol">(</a><a id="3689" href="SExp.html#208" class="InductiveConstructor">Pair</a> <a id="3694" class="Symbol">(</a><a id="3695" href="SExp.html#185" class="InductiveConstructor">Atom</a> <a id="3700" class="String">&quot;pair&quot;</a><a id="3706" class="Symbol">)</a> <a id="3708" class="Symbol">(</a><a id="3709" href="SExp.html#185" class="InductiveConstructor">Atom</a> <a id="3714" class="String">&quot;based&quot;</a><a id="3721" class="Symbol">)))</a>
                <a id="3741" class="Symbol">(</a><a id="3742" href="SExp.html#208" class="InductiveConstructor">Pair</a> <a id="3747" class="Symbol">(</a><a id="3748" href="SExp.html#185" class="InductiveConstructor">Atom</a> <a id="3753" class="String">&quot;S&quot;</a><a id="3756" class="Symbol">)</a>
                      <a id="3780" class="Symbol">(</a><a id="3781" href="SExp.html#185" class="InductiveConstructor">Atom</a> <a id="3786" class="String">&quot;expression&quot;</a><a id="3798" class="Symbol">)))</a> <a id="3802" href="Base.html#1338" class="InductiveConstructor Operator">!</a>
</pre></body></html>