<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SExp</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="SExp.html" class="Module">SExp</a> <a id="13" class="Keyword">where</a>

<a id="20" class="Keyword">open</a> <a id="25" class="Keyword">import</a> <a id="32" href="Level.html" class="Module">Level</a> <a id="38" class="Keyword">using</a> <a id="44" class="Symbol">(</a><a id="45" href="Level.html#512" class="Function">0ℓ</a><a id="47" class="Symbol">)</a>
<a id="49" class="Keyword">open</a> <a id="54" class="Keyword">import</a> <a id="61" href="Level.Bounded.html" class="Module">Level.Bounded</a> <a id="75" class="Keyword">using</a> <a id="81" class="Symbol">(</a><a id="82" href="Level.Bounded.html#931" class="Field">theSet</a><a id="88" class="Symbol">)</a>
<a id="90" class="Keyword">open</a> <a id="95" class="Keyword">import</a> <a id="102" href="Data.Char.Base.html" class="Module">Data.Char.Base</a>
<a id="117" class="Keyword">open</a> <a id="122" class="Keyword">import</a> <a id="129" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="146" class="Symbol">as</a> <a id="149" class="Module">String</a> <a id="156" class="Keyword">using</a> <a id="162" class="Symbol">(</a><a id="163" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="169" class="Symbol">)</a>

<a id="172" class="Keyword">data</a> <a id="SExp"></a><a id="177" href="SExp.html#177" class="Datatype">SExp</a> <a id="182" class="Symbol">:</a> <a id="184" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="188" class="Keyword">where</a>
  <a id="SExp.Atom"></a><a id="196" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="201" class="Symbol">:</a> <a id="203" href="Agda.Builtin.String.html#336" class="Postulate">String</a> <a id="210" class="Symbol">→</a> <a id="212" href="SExp.html#177" class="Datatype">SExp</a>
  <a id="SExp.Pair"></a><a id="219" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="224" class="Symbol">:</a> <a id="226" href="SExp.html#177" class="Datatype">SExp</a> <a id="231" class="Symbol">→</a> <a id="233" href="SExp.html#177" class="Datatype">SExp</a> <a id="238" class="Symbol">→</a> <a id="240" href="SExp.html#177" class="Datatype">SExp</a>

<a id="246" class="Keyword">open</a> <a id="251" class="Keyword">import</a> <a id="258" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="273" class="Keyword">open</a> <a id="278" class="Keyword">import</a> <a id="285" href="Data.List.Sized.Interface.html" class="Module">Data.List.Sized.Interface</a>
<a id="311" class="Keyword">open</a> <a id="316" class="Keyword">import</a> <a id="323" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="342" class="Symbol">as</a> <a id="345" class="Module">List⁺</a> <a id="351" class="Keyword">using</a> <a id="357" class="Symbol">(</a><a id="358" href="Data.List.NonEmpty.Base.html#1079" class="Record">List⁺</a><a id="363" class="Symbol">)</a>
<a id="365" class="Keyword">open</a> <a id="370" class="Keyword">import</a> <a id="377" href="Data.Maybe.html" class="Module">Data.Maybe</a>
<a id="388" class="Keyword">open</a> <a id="393" class="Keyword">import</a> <a id="400" href="Data.Product.html" class="Module">Data.Product</a>
<a id="413" class="Keyword">open</a> <a id="418" class="Keyword">import</a> <a id="425" href="Data.Subset.html" class="Module">Data.Subset</a>
<a id="437" class="Keyword">open</a> <a id="442" class="Keyword">import</a> <a id="449" href="Function.Base.html" class="Module">Function.Base</a>
<a id="463" class="Keyword">open</a> <a id="468" class="Keyword">import</a> <a id="475" href="Induction.Nat.Strong.html" class="Module">Induction.Nat.Strong</a>
<a id="496" class="Keyword">open</a> <a id="501" class="Keyword">import</a> <a id="508" href="Relation.Binary.PropositionalEquality.Decidable.html" class="Module">Relation.Binary.PropositionalEquality.Decidable</a>

<a id="557" class="Keyword">open</a> <a id="562" class="Keyword">import</a> <a id="569" href="Text.Parser.html" class="Module">Text.Parser</a>

<a id="582" class="Keyword">module</a> <a id="589" href="SExp.html#589" class="Module">_</a> <a id="591" class="Keyword">where</a>

  <a id="600" href="SExp.html#600" class="Function">sexp</a> <a id="605" class="Symbol">:</a> <a id="607" href="Relation.Unary.html#3359" class="Function">∀[</a> <a id="610" href="Text.Parser.html#2710" class="Function">Parser</a> <a id="617" href="SExp.html#177" class="Datatype">SExp</a> <a id="622" href="Relation.Unary.html#3359" class="Function">]</a>
  <a id="626" href="SExp.html#600" class="Function">sexp</a> <a id="631" class="Symbol">=</a>
    <a id="637" class="Comment">-- SExp is an inductive type so we build the parser as a fixpoint</a>
    <a id="707" href="Induction.Nat.Strong.html#1188" class="Function">fix</a> <a id="711" class="Symbol">(</a><a id="712" href="Text.Parser.html#2710" class="Function">Parser</a> <a id="719" href="SExp.html#177" class="Datatype">SExp</a><a id="723" class="Symbol">)</a> <a id="725" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="727" class="Symbol">λ</a> <a id="729" href="SExp.html#729" class="Bound">rec</a> <a id="733" class="Symbol">→</a>
        <a id="743" class="Comment">-- First we have atoms. Assuming we have already consumed the leading space, an</a>
        <a id="831" class="Comment">-- atom is just a non empty list of alphabetical characters.</a>

        <a id="901" class="Comment">-- We use `&lt;$&gt;` to turn that back into a string and apply the `Atom` constructor.</a>
    <a id="987" class="Keyword">let</a> <a id="991" href="SExp.html#991" class="Bound">atom</a> <a id="996" class="Symbol">=</a> <a id="998" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="1003" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="1005" href="Data.String.Base.html#1526" class="Primitive">String.fromList</a> <a id="1021" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="1023" href="Data.List.NonEmpty.Base.html#1521" class="Function">List⁺.toList</a>
               <a id="1051" href="Text.Parser.html#4418" class="Function Operator">&lt;$&gt;</a> <a id="1055" href="Text.Parser.html#7094" class="Function">list⁺</a> <a id="1061" href="Text.Parser.html#8472" class="Function">alpha</a>

        <a id="1076" class="Comment">-- Then we have subexpressions. Here we have to be a bit careful: we can have both</a>
        <a id="1167" class="Comment">-- * a sexp with additional parentheses à la `(e)`</a>
        <a id="1226" class="Comment">-- * pairing constructs à la `(e f)`</a>

        <a id="1272" class="Comment">-- In both cases they are surrounded by parentheses so we use `parens` and then we</a>
        <a id="1363" class="Comment">-- 1. unconditionally parse a subexpression thanks to `rec` introduced by the fixpoint earlier</a>
        <a id="1466" class="Comment">-- 2. _potentially_ consume a second subexpression (the `?`-tagged combinators are variants</a>
        <a id="1566" class="Comment">--    that are allowed to fail on the side the question mark is on).</a>

        <a id="1644" class="Comment">-- I give a bit more details about `lift` and `box` below.</a>
        <a id="1711" class="Comment">-- As for the previous case we use `&lt;$&gt;` to massage the result into a `SExp`.</a>
        <a id="1797" href="SExp.html#1797" class="Bound">sexp</a> <a id="1802" class="Symbol">=</a> <a id="1804" class="Symbol">(λ</a> <a id="1807" class="Symbol">(</a><a id="1808" href="SExp.html#1808" class="Bound">a</a> <a id="1810" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1812" href="SExp.html#1812" class="Bound">mb</a><a id="1814" class="Symbol">)</a> <a id="1816" class="Symbol">→</a> <a id="1818" href="Data.Maybe.Base.html#1362" class="Function">maybe</a> <a id="1824" class="Symbol">(</a><a id="1825" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="1830" href="SExp.html#1808" class="Bound">a</a><a id="1831" class="Symbol">)</a> <a id="1833" href="SExp.html#1808" class="Bound">a</a> <a id="1835" href="SExp.html#1812" class="Bound">mb</a><a id="1837" class="Symbol">)</a>
               <a id="1854" href="Text.Parser.html#4418" class="Function Operator">&lt;$&gt;</a> <a id="1858" href="Text.Parser.html#8162" class="Function">parens</a> <a id="1865" class="Symbol">(</a><a id="1866" href="Text.Parser.html#4014" class="Function">lift2</a> <a id="1872" class="Symbol">(λ</a> <a id="1875" href="SExp.html#1875" class="Bound">p</a> <a id="1877" href="SExp.html#1877" class="Bound">q</a> <a id="1879" class="Symbol">→</a> <a id="1881" href="Text.Parser.html#8281" class="Function">withSpaces</a> <a id="1892" href="SExp.html#1875" class="Bound">p</a> <a id="1894" href="Text.Parser.html#5484" class="Function Operator">&lt;&amp;?&gt;</a> <a id="1899" href="Text.Parser.html#3826" class="Function">box</a> <a id="1903" class="Symbol">(</a><a id="1904" href="SExp.html#1877" class="Bound">q</a> <a id="1906" href="Text.Parser.html#5572" class="Function Operator">&lt;&amp;?</a> <a id="1910" href="Text.Parser.html#3826" class="Function">box</a> <a id="1914" href="Text.Parser.html#7993" class="Function">spaces</a><a id="1920" class="Symbol">))</a>
                                 <a id="1956" href="SExp.html#729" class="Bound">rec</a>
                                 <a id="1993" href="SExp.html#729" class="Bound">rec</a><a id="1996" class="Symbol">)</a>
     <a id="2003" class="Keyword">in</a>

     <a id="2012" class="Comment">-- Finally we can put the two things together by using a simple disjunction</a>
     <a id="2093" href="SExp.html#991" class="Bound">atom</a> <a id="2098" href="Text.Parser.html#3943" class="Function Operator">&lt;|&gt;</a> <a id="2102" href="SExp.html#1797" class="Bound">sexp</a>


        <a id="2117" class="Comment">-- `lift`:</a>
        <a id="2136" class="Comment">-- parens is guaranteed to consume some of its input before calling its argument so</a>
        <a id="2228" class="Comment">-- the argument is guarded. We are however not making a direct call to `rec` in a guarded</a>
        <a id="2326" class="Comment">-- position: we are taking a (potentially failing) pairing of two sub-parsers, potentially</a>
        <a id="2425" class="Comment">-- eating some space, etc. So we use `lift2` as a way to distribute the proof that we are in</a>
        <a id="2526" class="Comment">-- a guarded position to the key elements that need it.</a>

        <a id="2591" class="Comment">-- `box`:</a>
        <a id="2609" class="Comment">-- sometimes on the other hand we have a guarded call but do not actually care. We can use</a>
        <a id="2708" class="Comment">-- `box` to discard the proof and use a normal parser in that guarded position.</a>


  <a id="2792" class="Comment">-- The full parser is obtained by disregarding spaces before &amp; after the expression</a>
  <a id="2878" href="SExp.html#2878" class="Function">SEXP</a> <a id="2883" class="Symbol">:</a> <a id="2885" href="Relation.Unary.html#3359" class="Function">∀[</a> <a id="2888" href="Text.Parser.html#2710" class="Function">Parser</a> <a id="2895" href="SExp.html#177" class="Datatype">SExp</a> <a id="2900" href="Relation.Unary.html#3359" class="Function">]</a>
  <a id="2904" href="SExp.html#2878" class="Function">SEXP</a> <a id="2909" class="Symbol">=</a> <a id="2911" href="Text.Parser.html#7993" class="Function">spaces</a> <a id="2918" href="Text.Parser.html#6011" class="Function Operator">?&amp;&gt;</a> <a id="2922" href="SExp.html#600" class="Function">sexp</a> <a id="2927" href="Text.Parser.html#5572" class="Function Operator">&lt;&amp;?</a> <a id="2931" href="Text.Parser.html#3826" class="Function">box</a> <a id="2935" href="Text.Parser.html#7993" class="Function">spaces</a>

<a id="2943" class="Comment">-- And we can run the thing on a test (which is very convenient when refactoring grammars!..):</a>
<a id="3038" href="SExp.html#3038" class="Function">_</a> <a id="3040" class="Symbol">:</a> <a id="3042" class="String">&quot;((  this    is)
      ((a (  pair based))
          ((S)(expression  ))))   &quot;</a> <a id="3121" href="Text.Parser.html#3276" class="Function Operator">∈</a> <a id="3123" href="SExp.html#2878" class="Function">SEXP</a>
<a id="3128" class="Symbol">_</a> <a id="3130" class="Symbol">=</a> <a id="3132" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3137" class="Symbol">(</a><a id="3138" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3143" class="Symbol">(</a><a id="3144" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3149" class="String">&quot;this&quot;</a><a id="3155" class="Symbol">)</a> <a id="3157" class="Symbol">(</a><a id="3158" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3163" class="String">&quot;is&quot;</a><a id="3167" class="Symbol">))</a>
         <a id="3179" class="Symbol">(</a><a id="3180" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3185" class="Symbol">(</a><a id="3186" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3191" class="Symbol">(</a><a id="3192" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3197" class="String">&quot;a&quot;</a><a id="3200" class="Symbol">)</a>
                     <a id="3223" class="Symbol">(</a><a id="3224" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3229" class="Symbol">(</a><a id="3230" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3235" class="String">&quot;pair&quot;</a><a id="3241" class="Symbol">)</a> <a id="3243" class="Symbol">(</a><a id="3244" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3249" class="String">&quot;based&quot;</a><a id="3256" class="Symbol">)))</a>
                <a id="3276" class="Symbol">(</a><a id="3277" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3282" class="Symbol">(</a><a id="3283" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3288" class="String">&quot;S&quot;</a><a id="3291" class="Symbol">)</a>
                      <a id="3315" class="Symbol">(</a><a id="3316" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3321" class="String">&quot;expression&quot;</a><a id="3333" class="Symbol">)))</a> <a id="3337" href="Data.Singleton.html#386" class="InductiveConstructor Operator">!</a>
</pre></body></html>