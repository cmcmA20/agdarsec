<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SExp</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--guardedness</a> <a id="27" class="Symbol">#-}</a>

<a id="32" class="Keyword">module</a> <a id="39" href="SExp.html" class="Module">SExp</a> <a id="44" class="Keyword">where</a>

<a id="51" class="Keyword">open</a> <a id="56" class="Keyword">import</a> <a id="63" href="Level.html" class="Module">Level</a> <a id="69" class="Keyword">using</a> <a id="75" class="Symbol">(</a><a id="76" href="Level.html#512" class="Function">0ℓ</a><a id="78" class="Symbol">)</a>
<a id="80" class="Keyword">open</a> <a id="85" class="Keyword">import</a> <a id="92" href="Level.Bounded.html" class="Module">Level.Bounded</a> <a id="106" class="Keyword">using</a> <a id="112" class="Symbol">(</a><a id="113" href="Level.Bounded.html#931" class="Field">theSet</a><a id="119" class="Symbol">)</a>
<a id="121" class="Keyword">open</a> <a id="126" class="Keyword">import</a> <a id="133" href="Data.Char.Base.html" class="Module">Data.Char.Base</a>
<a id="148" class="Keyword">open</a> <a id="153" class="Keyword">import</a> <a id="160" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="177" class="Symbol">as</a> <a id="180" class="Module">String</a> <a id="187" class="Keyword">using</a> <a id="193" class="Symbol">(</a><a id="194" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="200" class="Symbol">)</a>

<a id="203" class="Keyword">data</a> <a id="SExp"></a><a id="208" href="SExp.html#208" class="Datatype">SExp</a> <a id="213" class="Symbol">:</a> <a id="215" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="219" class="Keyword">where</a>
  <a id="SExp.Atom"></a><a id="227" href="SExp.html#227" class="InductiveConstructor">Atom</a> <a id="232" class="Symbol">:</a> <a id="234" href="Agda.Builtin.String.html#336" class="Postulate">String</a> <a id="241" class="Symbol">→</a> <a id="243" href="SExp.html#208" class="Datatype">SExp</a>
  <a id="SExp.Pair"></a><a id="250" href="SExp.html#250" class="InductiveConstructor">Pair</a> <a id="255" class="Symbol">:</a> <a id="257" href="SExp.html#208" class="Datatype">SExp</a> <a id="262" class="Symbol">→</a> <a id="264" href="SExp.html#208" class="Datatype">SExp</a> <a id="269" class="Symbol">→</a> <a id="271" href="SExp.html#208" class="Datatype">SExp</a>

<a id="277" class="Keyword">open</a> <a id="282" class="Keyword">import</a> <a id="289" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="304" class="Keyword">open</a> <a id="309" class="Keyword">import</a> <a id="316" href="Data.List.Sized.Interface.html" class="Module">Data.List.Sized.Interface</a>
<a id="342" class="Keyword">open</a> <a id="347" class="Keyword">import</a> <a id="354" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="373" class="Symbol">as</a> <a id="376" class="Module">List⁺</a> <a id="382" class="Keyword">using</a> <a id="388" class="Symbol">(</a><a id="389" href="Data.List.NonEmpty.Base.html#1079" class="Record">List⁺</a><a id="394" class="Symbol">)</a>
<a id="396" class="Keyword">open</a> <a id="401" class="Keyword">import</a> <a id="408" href="Data.Maybe.html" class="Module">Data.Maybe</a>
<a id="419" class="Keyword">open</a> <a id="424" class="Keyword">import</a> <a id="431" href="Data.Product.html" class="Module">Data.Product</a>
<a id="444" class="Keyword">open</a> <a id="449" class="Keyword">import</a> <a id="456" href="Data.Subset.html" class="Module">Data.Subset</a>
<a id="468" class="Keyword">open</a> <a id="473" class="Keyword">import</a> <a id="480" href="Function.Base.html" class="Module">Function.Base</a>
<a id="494" class="Keyword">open</a> <a id="499" class="Keyword">import</a> <a id="506" href="Induction.Nat.Strong.html" class="Module">Induction.Nat.Strong</a>
<a id="527" class="Keyword">open</a> <a id="532" class="Keyword">import</a> <a id="539" href="Relation.Unary.html" class="Module">Relation.Unary</a> <a id="554" class="Keyword">using</a> <a id="560" class="Symbol">(</a><a id="561" href="Relation.Unary.html#3359" class="Function">IUniversal</a> <a id="572" class="Symbol">;</a> <a id="574" href="Relation.Unary.html#4338" class="Function Operator">_⇒_</a><a id="577" class="Symbol">)</a>
<a id="579" class="Keyword">open</a> <a id="584" class="Keyword">import</a> <a id="591" href="Relation.Binary.PropositionalEquality.Decidable.html" class="Module">Relation.Binary.PropositionalEquality.Decidable</a>

<a id="640" class="Keyword">open</a> <a id="645" class="Keyword">import</a> <a id="652" href="Text.Parser.html" class="Module">Text.Parser</a> <a id="664" href="Level.html#512" class="Function">0ℓ</a>

<a id="668" class="Keyword">module</a> <a id="675" href="SExp.html#675" class="Module">_</a> <a id="677" class="Keyword">where</a>

  <a id="686" href="SExp.html#686" class="Function">sexp</a> <a id="691" class="Symbol">:</a> <a id="693" href="Relation.Unary.html#3359" class="Function">∀[</a> <a id="696" href="Text.Parser.Types.html#564" class="Record">Parser</a> <a id="703" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="705" href="SExp.html#208" class="Datatype">SExp</a> <a id="710" href="Level.Bounded.html#1072" class="Function Operator">]</a> <a id="712" href="Relation.Unary.html#3359" class="Function">]</a>
  <a id="716" href="SExp.html#686" class="Function">sexp</a> <a id="721" class="Symbol">=</a>
    <a id="727" class="Comment">-- SExp is an inductive type so we build the parser as a fixpoint</a>
    <a id="797" href="Induction.Nat.Strong.html#1188" class="Function">fix</a> <a id="801" class="Symbol">(</a><a id="802" href="Text.Parser.Types.html#564" class="Record">Parser</a> <a id="809" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="811" href="SExp.html#208" class="Datatype">SExp</a> <a id="816" href="Level.Bounded.html#1072" class="Function Operator">]</a><a id="817" class="Symbol">)</a> <a id="819" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="821" class="Symbol">λ</a> <a id="823" href="SExp.html#823" class="Bound">rec</a> <a id="827" class="Symbol">→</a>
        <a id="837" class="Comment">-- First we have atoms. Assuming we have already consumed the leading space, an</a>
        <a id="925" class="Comment">-- atom is just a non empty list of alphabetical characters.</a>

        <a id="995" class="Comment">-- We use `&lt;$&gt;` to turn that back into a string and apply the `Atom` constructor.</a>
    <a id="1081" class="Keyword">let</a> <a id="1085" href="SExp.html#1085" class="Bound">atom</a> <a id="1090" class="Symbol">=</a> <a id="1092" href="SExp.html#227" class="InductiveConstructor">Atom</a> <a id="1097" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="1099" href="Data.String.Base.html#1526" class="Primitive">String.fromList</a> <a id="1115" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="1117" href="Data.List.NonEmpty.Base.html#1521" class="Function">List⁺.toList</a>
               <a id="1145" href="Text.Parser.Combinators.html#3101" class="Function Operator">&lt;$&gt;</a> <a id="1149" href="Text.Parser.Combinators.html#9287" class="Function">list⁺</a> <a id="1155" href="Text.Parser.Combinators.Char.html#2627" class="Function">alpha</a>

        <a id="1170" class="Comment">-- Then we have subexpressions. Here we have to be a bit careful: we can have both</a>
        <a id="1261" class="Comment">-- * a sexp with additional parentheses à la `(e)`</a>
        <a id="1320" class="Comment">-- * pairing constructs à la `(e f)`</a>

        <a id="1366" class="Comment">-- In both cases they are surrounded by parentheses so we use `parens` and then we</a>
        <a id="1457" class="Comment">-- 1. unconditionally parse a subexpression thanks to `rec` introduced by the fixpoint earlier</a>
        <a id="1560" class="Comment">-- 2. _potentially_ consume a second subexpression (the `?`-tagged combinators are variants</a>
        <a id="1660" class="Comment">--    that are allowed to fail on the side the question mark is on).</a>

        <a id="1738" class="Comment">-- I give a bit more details about `lift` and `box` below.</a>
        <a id="1805" class="Comment">-- As for the previous case we use `&lt;$&gt;` to massage the result into a `SExp`.</a>
        <a id="1891" href="SExp.html#1891" class="Bound">sexp</a> <a id="1896" class="Symbol">=</a> <a id="1898" class="Symbol">(λ</a> <a id="1901" class="Symbol">(</a><a id="1902" href="SExp.html#1902" class="Bound">a</a> <a id="1904" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1906" href="SExp.html#1906" class="Bound">mb</a><a id="1908" class="Symbol">)</a> <a id="1910" class="Symbol">→</a> <a id="1912" href="Data.Maybe.Base.html#1362" class="Function">maybe</a> <a id="1918" class="Symbol">(</a><a id="1919" href="SExp.html#250" class="InductiveConstructor">Pair</a> <a id="1924" href="SExp.html#1902" class="Bound">a</a><a id="1925" class="Symbol">)</a> <a id="1927" href="SExp.html#1902" class="Bound">a</a> <a id="1929" href="SExp.html#1906" class="Bound">mb</a><a id="1931" class="Symbol">)</a>
               <a id="1948" href="Text.Parser.Combinators.html#3101" class="Function Operator">&lt;$&gt;</a> <a id="1952" href="Text.Parser.Combinators.Char.html#2089" class="Function">parens</a> <a id="1959" class="Symbol">(</a><a id="1960" href="Text.Parser.Combinators.html#2644" class="Function">lift2</a> <a id="1966" class="Symbol">(λ</a> <a id="1969" href="SExp.html#1969" class="Bound">p</a> <a id="1971" href="SExp.html#1971" class="Bound">q</a> <a id="1973" class="Symbol">→</a> <a id="1975" class="Symbol">(</a><a id="1976" href="Text.Parser.Combinators.Char.html#1790" class="Function">spaces</a> <a id="1983" href="Text.Parser.Combinators.html#6065" class="Function Operator">?&amp;&gt;</a> <a id="1987" href="SExp.html#1969" class="Bound">p</a> <a id="1989" href="Text.Parser.Combinators.html#5550" class="Function Operator">&lt;&amp;?</a> <a id="1993" href="Text.Parser.Combinators.html#2357" class="Function">box</a> <a id="1997" href="Text.Parser.Combinators.Char.html#1790" class="Function">spaces</a><a id="2003" class="Symbol">)</a> <a id="2005" href="Text.Parser.Combinators.html#5459" class="Function Operator">&lt;&amp;?&gt;</a> <a id="2010" href="Text.Parser.Combinators.html#2357" class="Function">box</a> <a id="2014" class="Symbol">(</a><a id="2015" href="SExp.html#1971" class="Bound">q</a> <a id="2017" href="Text.Parser.Combinators.html#5550" class="Function Operator">&lt;&amp;?</a> <a id="2021" href="Text.Parser.Combinators.html#2357" class="Function">box</a> <a id="2025" href="Text.Parser.Combinators.Char.html#1790" class="Function">spaces</a><a id="2031" class="Symbol">))</a>
                                 <a id="2067" href="SExp.html#823" class="Bound">rec</a>
                                 <a id="2104" href="SExp.html#823" class="Bound">rec</a><a id="2107" class="Symbol">)</a>
     <a id="2114" class="Keyword">in</a>

     <a id="2123" class="Comment">-- Finally we can put the two things together by using a simple disjunction</a>
     <a id="2204" href="SExp.html#1085" class="Bound">atom</a> <a id="2209" href="Text.Parser.Combinators.html#2489" class="Function Operator">&lt;|&gt;</a> <a id="2213" href="SExp.html#1891" class="Bound">sexp</a>


        <a id="2228" class="Comment">-- `lift`:</a>
        <a id="2247" class="Comment">-- parens is guaranteed to consume some of its input before calling its argument so</a>
        <a id="2339" class="Comment">-- the argument is guarded. We are however not making a direct call to `rec` in a guarded</a>
        <a id="2437" class="Comment">-- position: we are taking a (potentially failing) pairing of two sub-parsers, potentially</a>
        <a id="2536" class="Comment">-- eating some space, etc. So we use `lift2` as a way to distribute the proof that we are in</a>
        <a id="2637" class="Comment">-- a guarded position to the key elements that need it.</a>

        <a id="2702" class="Comment">-- `box`:</a>
        <a id="2720" class="Comment">-- sometimes on the other hand we have a guarded call but do not actually care. We can use</a>
        <a id="2819" class="Comment">-- `box` to discard the proof and use a normal parser in that guarded position.</a>


  <a id="2903" class="Comment">-- The full parser is obtained by disregarding spaces before &amp; after the expression</a>
  <a id="2989" href="SExp.html#2989" class="Function">SEXP</a> <a id="2994" class="Symbol">:</a> <a id="2996" href="Relation.Unary.html#3359" class="Function">∀[</a> <a id="2999" href="Text.Parser.Types.html#564" class="Record">Parser</a> <a id="3006" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="3008" href="SExp.html#208" class="Datatype">SExp</a> <a id="3013" href="Level.Bounded.html#1072" class="Function Operator">]</a> <a id="3015" href="Relation.Unary.html#3359" class="Function">]</a>
  <a id="3019" href="SExp.html#2989" class="Function">SEXP</a> <a id="3024" class="Symbol">=</a> <a id="3026" href="Text.Parser.Combinators.Char.html#1790" class="Function">spaces</a> <a id="3033" href="Text.Parser.Combinators.html#6065" class="Function Operator">?&amp;&gt;</a> <a id="3037" href="SExp.html#686" class="Function">sexp</a> <a id="3042" href="Text.Parser.Combinators.html#5550" class="Function Operator">&lt;&amp;?</a> <a id="3046" href="Text.Parser.Combinators.html#2357" class="Function">box</a> <a id="3050" href="Text.Parser.Combinators.Char.html#1790" class="Function">spaces</a>

<a id="3058" class="Keyword">open</a> <a id="3063" class="Keyword">import</a> <a id="3070" href="Base.html" class="Module">Base</a> <a id="3075" href="Agda.Primitive.html#764" class="Primitive">Level.zero</a>

<a id="3087" class="Comment">-- And we can run the thing on a test (which is very convenient when refactoring grammars!..):</a>
<a id="3182" href="SExp.html#3182" class="Function">_</a> <a id="3184" class="Symbol">:</a> <a id="3186" class="String">&quot;((  this    is)
      ((a (  pair based))
          ((S)(expression  ))))   &quot;</a> <a id="3265" href="Base.html#3339" class="Function Operator">∈</a> <a id="3267" href="SExp.html#2989" class="Function">SEXP</a>
<a id="3272" class="Symbol">_</a> <a id="3274" class="Symbol">=</a> <a id="3276" href="SExp.html#250" class="InductiveConstructor">Pair</a> <a id="3281" class="Symbol">(</a><a id="3282" href="SExp.html#250" class="InductiveConstructor">Pair</a> <a id="3287" class="Symbol">(</a><a id="3288" href="SExp.html#227" class="InductiveConstructor">Atom</a> <a id="3293" class="String">&quot;this&quot;</a><a id="3299" class="Symbol">)</a> <a id="3301" class="Symbol">(</a><a id="3302" href="SExp.html#227" class="InductiveConstructor">Atom</a> <a id="3307" class="String">&quot;is&quot;</a><a id="3311" class="Symbol">))</a>
         <a id="3323" class="Symbol">(</a><a id="3324" href="SExp.html#250" class="InductiveConstructor">Pair</a> <a id="3329" class="Symbol">(</a><a id="3330" href="SExp.html#250" class="InductiveConstructor">Pair</a> <a id="3335" class="Symbol">(</a><a id="3336" href="SExp.html#227" class="InductiveConstructor">Atom</a> <a id="3341" class="String">&quot;a&quot;</a><a id="3344" class="Symbol">)</a>
                     <a id="3367" class="Symbol">(</a><a id="3368" href="SExp.html#250" class="InductiveConstructor">Pair</a> <a id="3373" class="Symbol">(</a><a id="3374" href="SExp.html#227" class="InductiveConstructor">Atom</a> <a id="3379" class="String">&quot;pair&quot;</a><a id="3385" class="Symbol">)</a> <a id="3387" class="Symbol">(</a><a id="3388" href="SExp.html#227" class="InductiveConstructor">Atom</a> <a id="3393" class="String">&quot;based&quot;</a><a id="3400" class="Symbol">)))</a>
                <a id="3420" class="Symbol">(</a><a id="3421" href="SExp.html#250" class="InductiveConstructor">Pair</a> <a id="3426" class="Symbol">(</a><a id="3427" href="SExp.html#227" class="InductiveConstructor">Atom</a> <a id="3432" class="String">&quot;S&quot;</a><a id="3435" class="Symbol">)</a>
                      <a id="3459" class="Symbol">(</a><a id="3460" href="SExp.html#227" class="InductiveConstructor">Atom</a> <a id="3465" class="String">&quot;expression&quot;</a><a id="3477" class="Symbol">)))</a> <a id="3481" href="Base.html#1550" class="InductiveConstructor Operator">!</a>
</pre></body></html>