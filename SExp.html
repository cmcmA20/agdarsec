<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SExp</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="SExp.html" class="Module">SExp</a> <a id="13" class="Keyword">where</a>

<a id="20" class="Keyword">open</a> <a id="25" class="Keyword">import</a> <a id="32" href="Level.html" class="Module">Level</a> <a id="38" class="Keyword">using</a> <a id="44" class="Symbol">(</a><a id="45" href="Level.html#512" class="Function">0ℓ</a><a id="47" class="Symbol">)</a>
<a id="49" class="Keyword">open</a> <a id="54" class="Keyword">import</a> <a id="61" href="Level.Bounded.html" class="Module">Level.Bounded</a> <a id="75" class="Keyword">using</a> <a id="81" class="Symbol">(</a><a id="82" href="Level.Bounded.html#931" class="Field">theSet</a><a id="88" class="Symbol">;</a> <a id="90" href="Level.Bounded.html#1072" class="Function Operator">[_]</a><a id="93" class="Symbol">)</a>
<a id="95" class="Keyword">open</a> <a id="100" class="Keyword">import</a> <a id="107" href="Data.Char.Base.html" class="Module">Data.Char.Base</a>
<a id="122" class="Keyword">open</a> <a id="127" class="Keyword">import</a> <a id="134" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="151" class="Symbol">as</a> <a id="154" class="Module">String</a> <a id="161" class="Keyword">using</a> <a id="167" class="Symbol">(</a><a id="168" href="Agda.Builtin.String.html#274" class="Postulate">String</a><a id="174" class="Symbol">)</a>

<a id="177" class="Keyword">data</a> <a id="SExp"></a><a id="182" href="SExp.html#182" class="Datatype">SExp</a> <a id="187" class="Symbol">:</a> <a id="189" class="PrimitiveType">Set</a> <a id="193" class="Keyword">where</a>
  <a id="SExp.Atom"></a><a id="201" href="SExp.html#201" class="InductiveConstructor">Atom</a> <a id="206" class="Symbol">:</a> <a id="208" href="Agda.Builtin.String.html#274" class="Postulate">String</a> <a id="215" class="Symbol">→</a> <a id="217" href="SExp.html#182" class="Datatype">SExp</a>
  <a id="SExp.Pair"></a><a id="224" href="SExp.html#224" class="InductiveConstructor">Pair</a> <a id="229" class="Symbol">:</a> <a id="231" href="SExp.html#182" class="Datatype">SExp</a> <a id="236" class="Symbol">→</a> <a id="238" href="SExp.html#182" class="Datatype">SExp</a> <a id="243" class="Symbol">→</a> <a id="245" href="SExp.html#182" class="Datatype">SExp</a>

<a id="251" class="Keyword">open</a> <a id="256" class="Keyword">import</a> <a id="263" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="278" class="Keyword">open</a> <a id="283" class="Keyword">import</a> <a id="290" href="Data.List.Sized.Interface.html" class="Module">Data.List.Sized.Interface</a>
<a id="316" class="Keyword">open</a> <a id="321" class="Keyword">import</a> <a id="328" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="347" class="Symbol">as</a> <a id="350" class="Module">List⁺</a> <a id="356" class="Keyword">using</a> <a id="362" class="Symbol">(</a><a id="363" href="Data.List.NonEmpty.html#1318" class="Record">List⁺</a><a id="368" class="Symbol">)</a>
<a id="370" class="Keyword">open</a> <a id="375" class="Keyword">import</a> <a id="382" href="Data.Maybe.html" class="Module">Data.Maybe</a>
<a id="393" class="Keyword">open</a> <a id="398" class="Keyword">import</a> <a id="405" href="Data.Product.html" class="Module">Data.Product</a>
<a id="418" class="Keyword">open</a> <a id="423" class="Keyword">import</a> <a id="430" href="Data.Subset.html" class="Module">Data.Subset</a>
<a id="442" class="Keyword">open</a> <a id="447" class="Keyword">import</a> <a id="454" href="Function.Base.html" class="Module">Function.Base</a>
<a id="468" class="Keyword">open</a> <a id="473" class="Keyword">import</a> <a id="480" href="Induction.Nat.Strong.html" class="Module">Induction.Nat.Strong</a>
<a id="501" class="Keyword">open</a> <a id="506" class="Keyword">import</a> <a id="513" href="Relation.Unary.html" class="Module">Relation.Unary</a> <a id="528" class="Keyword">using</a> <a id="534" class="Symbol">(</a><a id="535" href="Relation.Unary.html#3359" class="Function">IUniversal</a> <a id="546" class="Symbol">;</a> <a id="548" href="Relation.Unary.html#4338" class="Function Operator">_⇒_</a><a id="551" class="Symbol">)</a>
<a id="553" class="Keyword">open</a> <a id="558" class="Keyword">import</a> <a id="565" href="Relation.Binary.PropositionalEquality.Decidable.html" class="Module">Relation.Binary.PropositionalEquality.Decidable</a>

<a id="614" class="Keyword">open</a> <a id="619" class="Keyword">import</a> <a id="626" href="Text.Parser.html" class="Module">Text.Parser</a> <a id="638" href="Level.html#512" class="Function">0ℓ</a>

<a id="642" class="Keyword">module</a> <a id="649" href="SExp.html#649" class="Module">_</a> <a id="651" class="Keyword">where</a>

  <a id="660" href="SExp.html#660" class="Function">sexp</a> <a id="665" class="Symbol">:</a> <a id="667" href="Relation.Unary.html#3359" class="Function">∀[</a> <a id="670" href="Text.Parser.Types.html#564" class="Record">Parser</a> <a id="677" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="679" href="SExp.html#182" class="Datatype">SExp</a> <a id="684" href="Level.Bounded.html#1072" class="Function Operator">]</a> <a id="686" href="Relation.Unary.html#3359" class="Function">]</a>
  <a id="690" href="SExp.html#660" class="Function">sexp</a> <a id="695" class="Symbol">=</a>
    <a id="701" class="Comment">-- SExp is an inductive type so we build the parser as a fixpoint</a>
    <a id="771" href="Induction.Nat.Strong.html#1188" class="Function">fix</a> <a id="775" class="Symbol">(</a><a id="776" href="Text.Parser.Types.html#564" class="Record">Parser</a> <a id="783" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="785" href="SExp.html#182" class="Datatype">SExp</a> <a id="790" href="Level.Bounded.html#1072" class="Function Operator">]</a><a id="791" class="Symbol">)</a> <a id="793" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="795" class="Symbol">λ</a> <a id="797" href="SExp.html#797" class="Bound">rec</a> <a id="801" class="Symbol">→</a>
        <a id="811" class="Comment">-- First we have atoms. Assuming we have already consumed the leading space, an</a>
        <a id="899" class="Comment">-- atom is just a non empty list of alphabetical characters.</a>

        <a id="969" class="Comment">-- We use `&lt;$&gt;` to turn that back into a string and apply the `Atom` constructor.</a>
    <a id="1055" class="Keyword">let</a> <a id="1059" href="SExp.html#1059" class="Bound">atom</a> <a id="1064" class="Symbol">=</a> <a id="1066" href="SExp.html#201" class="InductiveConstructor">Atom</a> <a id="1071" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="1073" href="Data.String.Base.html#1546" class="Primitive">String.fromList</a> <a id="1089" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="1091" href="Data.List.NonEmpty.html#1760" class="Function">List⁺.toList</a>
               <a id="1119" href="Text.Parser.Combinators.html#3005" class="Function Operator">&lt;$&gt;</a> <a id="1123" href="Text.Parser.Combinators.html#9191" class="Function">list⁺</a> <a id="1129" href="Text.Parser.Combinators.Char.html#2243" class="Function">alpha</a>

        <a id="1144" class="Comment">-- Then we have subexpressions. Here we have to be a bit careful: we can have both</a>
        <a id="1235" class="Comment">-- * a sexp with additional parentheses à la `(e)`</a>
        <a id="1294" class="Comment">-- * pairing constructs à la `(e f)`</a>

        <a id="1340" class="Comment">-- In both cases they are surrounded by parentheses so we use `parens` and then we</a>
        <a id="1431" class="Comment">-- 1. unconditionally parse a subexpression thanks to `rec` introduced by the fixpoint earlier</a>
        <a id="1534" class="Comment">-- 2. _potentially_ consume a second subexpression (the `?`-tagged combinators are variants</a>
        <a id="1634" class="Comment">--    that are allowed to fail on the side the question mark is on).</a>

        <a id="1712" class="Comment">-- I give a bit more details about `lift` and `box` below.</a>
        <a id="1779" class="Comment">-- As for the previous case we use `&lt;$&gt;` to massage the result into a `SExp`.</a>
        <a id="1865" href="SExp.html#1865" class="Bound">sexp</a> <a id="1870" class="Symbol">=</a> <a id="1872" class="Symbol">(λ</a> <a id="1875" class="Symbol">(</a><a id="1876" href="SExp.html#1876" class="Bound">a</a> <a id="1878" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1880" href="SExp.html#1880" class="Bound">mb</a><a id="1882" class="Symbol">)</a> <a id="1884" class="Symbol">→</a> <a id="1886" href="Data.Maybe.Base.html#1381" class="Function">maybe</a> <a id="1892" class="Symbol">(</a><a id="1893" href="SExp.html#224" class="InductiveConstructor">Pair</a> <a id="1898" href="SExp.html#1876" class="Bound">a</a><a id="1899" class="Symbol">)</a> <a id="1901" href="SExp.html#1876" class="Bound">a</a> <a id="1903" href="SExp.html#1880" class="Bound">mb</a><a id="1905" class="Symbol">)</a>
               <a id="1922" href="Text.Parser.Combinators.html#3005" class="Function Operator">&lt;$&gt;</a> <a id="1926" href="Text.Parser.Combinators.Char.html#1705" class="Function">parens</a> <a id="1933" class="Symbol">(</a><a id="1934" href="Text.Parser.Combinators.html#2548" class="Function">lift2</a> <a id="1940" class="Symbol">(λ</a> <a id="1943" href="SExp.html#1943" class="Bound">p</a> <a id="1945" href="SExp.html#1945" class="Bound">q</a> <a id="1947" class="Symbol">→</a> <a id="1949" class="Symbol">(</a><a id="1950" href="Text.Parser.Combinators.Char.html#1406" class="Function">spaces</a> <a id="1957" href="Text.Parser.Combinators.html#5969" class="Function Operator">?&amp;&gt;</a> <a id="1961" href="SExp.html#1943" class="Bound">p</a> <a id="1963" href="Text.Parser.Combinators.html#5454" class="Function Operator">&lt;&amp;?</a> <a id="1967" href="Text.Parser.Combinators.html#2261" class="Function">box</a> <a id="1971" href="Text.Parser.Combinators.Char.html#1406" class="Function">spaces</a><a id="1977" class="Symbol">)</a> <a id="1979" href="Text.Parser.Combinators.html#5363" class="Function Operator">&lt;&amp;?&gt;</a> <a id="1984" href="Text.Parser.Combinators.html#2261" class="Function">box</a> <a id="1988" class="Symbol">(</a><a id="1989" href="SExp.html#1945" class="Bound">q</a> <a id="1991" href="Text.Parser.Combinators.html#5454" class="Function Operator">&lt;&amp;?</a> <a id="1995" href="Text.Parser.Combinators.html#2261" class="Function">box</a> <a id="1999" href="Text.Parser.Combinators.Char.html#1406" class="Function">spaces</a><a id="2005" class="Symbol">))</a>
                                 <a id="2041" href="SExp.html#797" class="Bound">rec</a>
                                 <a id="2078" href="SExp.html#797" class="Bound">rec</a><a id="2081" class="Symbol">)</a>
     <a id="2088" class="Keyword">in</a>

     <a id="2097" class="Comment">-- Finally we can put the two things together by using a simple disjunction</a>
     <a id="2178" href="SExp.html#1059" class="Bound">atom</a> <a id="2183" href="Text.Parser.Combinators.html#2393" class="Function Operator">&lt;|&gt;</a> <a id="2187" href="SExp.html#1865" class="Bound">sexp</a>


        <a id="2202" class="Comment">-- `lift`:</a>
        <a id="2221" class="Comment">-- parens is guaranteed to consume some of its input before calling its argument so</a>
        <a id="2313" class="Comment">-- the argument is guarded. We are however not making a direct call to `rec` in a guarded</a>
        <a id="2411" class="Comment">-- position: we are taking a (potentially failing) pairing of two sub-parsers, potentially</a>
        <a id="2510" class="Comment">-- eating some space, etc. So we use `lift2` as a way to distribute the proof that we are in</a>
        <a id="2611" class="Comment">-- a guarded position to the key elements that need it.</a>

        <a id="2676" class="Comment">-- `box`:</a>
        <a id="2694" class="Comment">-- sometimes on the other hand we have a guarded call but do not actually care. We can use</a>
        <a id="2793" class="Comment">-- `box` to discard the proof and use a normal parser in that guarded position.</a>


  <a id="2877" class="Comment">-- The full parser is obtained by disregarding spaces before &amp; after the expression</a>
  <a id="2963" href="SExp.html#2963" class="Function">SEXP</a> <a id="2968" class="Symbol">:</a> <a id="2970" href="Relation.Unary.html#3359" class="Function">∀[</a> <a id="2973" href="Text.Parser.Types.html#564" class="Record">Parser</a> <a id="2980" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="2982" href="SExp.html#182" class="Datatype">SExp</a> <a id="2987" href="Level.Bounded.html#1072" class="Function Operator">]</a> <a id="2989" href="Relation.Unary.html#3359" class="Function">]</a>
  <a id="2993" href="SExp.html#2963" class="Function">SEXP</a> <a id="2998" class="Symbol">=</a> <a id="3000" href="Text.Parser.Combinators.Char.html#1406" class="Function">spaces</a> <a id="3007" href="Text.Parser.Combinators.html#5969" class="Function Operator">?&amp;&gt;</a> <a id="3011" href="SExp.html#660" class="Function">sexp</a> <a id="3016" href="Text.Parser.Combinators.html#5454" class="Function Operator">&lt;&amp;?</a> <a id="3020" href="Text.Parser.Combinators.html#2261" class="Function">box</a> <a id="3024" href="Text.Parser.Combinators.Char.html#1406" class="Function">spaces</a>

<a id="3032" class="Keyword">open</a> <a id="3037" class="Keyword">import</a> <a id="3044" href="Base.html" class="Module">Base</a> <a id="3049" href="Level.html#360" class="Primitive">Level.zero</a>

<a id="3061" class="Comment">-- And we can run the thing on a test (which is very convenient when refactoring grammars!..):</a>
<a id="3156" href="SExp.html#3156" class="Function">_</a> <a id="3158" class="Symbol">:</a> <a id="3160" class="String">&quot;((  this    is)
      ((a (  pair based))
          ((S)(expression  ))))   &quot;</a> <a id="3239" href="Base.html#3339" class="Function Operator">∈</a> <a id="3241" href="SExp.html#2963" class="Function">SEXP</a>
<a id="3246" class="Symbol">_</a> <a id="3248" class="Symbol">=</a> <a id="3250" href="SExp.html#224" class="InductiveConstructor">Pair</a> <a id="3255" class="Symbol">(</a><a id="3256" href="SExp.html#224" class="InductiveConstructor">Pair</a> <a id="3261" class="Symbol">(</a><a id="3262" href="SExp.html#201" class="InductiveConstructor">Atom</a> <a id="3267" class="String">&quot;this&quot;</a><a id="3273" class="Symbol">)</a> <a id="3275" class="Symbol">(</a><a id="3276" href="SExp.html#201" class="InductiveConstructor">Atom</a> <a id="3281" class="String">&quot;is&quot;</a><a id="3285" class="Symbol">))</a>
         <a id="3297" class="Symbol">(</a><a id="3298" href="SExp.html#224" class="InductiveConstructor">Pair</a> <a id="3303" class="Symbol">(</a><a id="3304" href="SExp.html#224" class="InductiveConstructor">Pair</a> <a id="3309" class="Symbol">(</a><a id="3310" href="SExp.html#201" class="InductiveConstructor">Atom</a> <a id="3315" class="String">&quot;a&quot;</a><a id="3318" class="Symbol">)</a>
                     <a id="3341" class="Symbol">(</a><a id="3342" href="SExp.html#224" class="InductiveConstructor">Pair</a> <a id="3347" class="Symbol">(</a><a id="3348" href="SExp.html#201" class="InductiveConstructor">Atom</a> <a id="3353" class="String">&quot;pair&quot;</a><a id="3359" class="Symbol">)</a> <a id="3361" class="Symbol">(</a><a id="3362" href="SExp.html#201" class="InductiveConstructor">Atom</a> <a id="3367" class="String">&quot;based&quot;</a><a id="3374" class="Symbol">)))</a>
                <a id="3394" class="Symbol">(</a><a id="3395" href="SExp.html#224" class="InductiveConstructor">Pair</a> <a id="3400" class="Symbol">(</a><a id="3401" href="SExp.html#201" class="InductiveConstructor">Atom</a> <a id="3406" class="String">&quot;S&quot;</a><a id="3409" class="Symbol">)</a>
                      <a id="3433" class="Symbol">(</a><a id="3434" href="SExp.html#201" class="InductiveConstructor">Atom</a> <a id="3439" class="String">&quot;expression&quot;</a><a id="3451" class="Symbol">)))</a> <a id="3455" href="Base.html#1550" class="InductiveConstructor Operator">!</a>
</pre></body></html>