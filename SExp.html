<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SExp</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="SExp.html" class="Module">SExp</a> <a id="13" class="Keyword">where</a>

<a id="20" class="Keyword">open</a> <a id="25" class="Keyword">import</a> <a id="32" href="Level.html" class="Module">Level</a> <a id="38" class="Keyword">using</a> <a id="44" class="Symbol">(</a><a id="45" href="Level.html#512" class="Function">0ℓ</a><a id="47" class="Symbol">)</a>
<a id="49" class="Keyword">open</a> <a id="54" class="Keyword">import</a> <a id="61" href="Level.Bounded.html" class="Module">Level.Bounded</a> <a id="75" class="Keyword">using</a> <a id="81" class="Symbol">(</a><a id="82" href="Level.Bounded.html#931" class="Field">theSet</a><a id="88" class="Symbol">)</a>
<a id="90" class="Keyword">open</a> <a id="95" class="Keyword">import</a> <a id="102" href="Data.Char.Base.html" class="Module">Data.Char.Base</a>
<a id="117" class="Keyword">open</a> <a id="122" class="Keyword">import</a> <a id="129" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="146" class="Symbol">as</a> <a id="149" class="Module">String</a> <a id="156" class="Keyword">using</a> <a id="162" class="Symbol">(</a><a id="163" href="Agda.Builtin.String.html#274" class="Postulate">String</a><a id="169" class="Symbol">)</a>

<a id="172" class="Keyword">data</a> <a id="SExp"></a><a id="177" href="SExp.html#177" class="Datatype">SExp</a> <a id="182" class="Symbol">:</a> <a id="184" class="PrimitiveType">Set</a> <a id="188" class="Keyword">where</a>
  <a id="SExp.Atom"></a><a id="196" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="201" class="Symbol">:</a> <a id="203" href="Agda.Builtin.String.html#274" class="Postulate">String</a> <a id="210" class="Symbol">→</a> <a id="212" href="SExp.html#177" class="Datatype">SExp</a>
  <a id="SExp.Pair"></a><a id="219" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="224" class="Symbol">:</a> <a id="226" href="SExp.html#177" class="Datatype">SExp</a> <a id="231" class="Symbol">→</a> <a id="233" href="SExp.html#177" class="Datatype">SExp</a> <a id="238" class="Symbol">→</a> <a id="240" href="SExp.html#177" class="Datatype">SExp</a>

<a id="246" class="Keyword">open</a> <a id="251" class="Keyword">import</a> <a id="258" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="273" class="Keyword">open</a> <a id="278" class="Keyword">import</a> <a id="285" href="Data.List.Sized.Interface.html" class="Module">Data.List.Sized.Interface</a>
<a id="311" class="Keyword">open</a> <a id="316" class="Keyword">import</a> <a id="323" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="342" class="Symbol">as</a> <a id="345" class="Module">List⁺</a> <a id="351" class="Keyword">using</a> <a id="357" class="Symbol">(</a><a id="358" href="Data.List.NonEmpty.html#1318" class="Record">List⁺</a><a id="363" class="Symbol">)</a>
<a id="365" class="Keyword">open</a> <a id="370" class="Keyword">import</a> <a id="377" href="Data.Maybe.html" class="Module">Data.Maybe</a>
<a id="388" class="Keyword">open</a> <a id="393" class="Keyword">import</a> <a id="400" href="Data.Product.html" class="Module">Data.Product</a>
<a id="413" class="Keyword">open</a> <a id="418" class="Keyword">import</a> <a id="425" href="Data.Subset.html" class="Module">Data.Subset</a>
<a id="437" class="Keyword">open</a> <a id="442" class="Keyword">import</a> <a id="449" href="Function.Base.html" class="Module">Function.Base</a>
<a id="463" class="Keyword">open</a> <a id="468" class="Keyword">import</a> <a id="475" href="Induction.Nat.Strong.html" class="Module">Induction.Nat.Strong</a>
<a id="496" class="Keyword">open</a> <a id="501" class="Keyword">import</a> <a id="508" href="Relation.Unary.html" class="Module">Relation.Unary</a> <a id="523" class="Keyword">using</a> <a id="529" class="Symbol">(</a><a id="530" href="Relation.Unary.html#3359" class="Function">IUniversal</a> <a id="541" class="Symbol">;</a> <a id="543" href="Relation.Unary.html#4338" class="Function Operator">_⇒_</a><a id="546" class="Symbol">)</a>
<a id="548" class="Keyword">open</a> <a id="553" class="Keyword">import</a> <a id="560" href="Relation.Binary.PropositionalEquality.Decidable.html" class="Module">Relation.Binary.PropositionalEquality.Decidable</a>

<a id="609" class="Keyword">open</a> <a id="614" class="Keyword">import</a> <a id="621" href="Text.Parser.html" class="Module">Text.Parser</a> <a id="633" href="Level.html#512" class="Function">0ℓ</a>

<a id="637" class="Keyword">module</a> <a id="644" href="SExp.html#644" class="Module">_</a> <a id="646" class="Keyword">where</a>

  <a id="655" href="SExp.html#655" class="Function">sexp</a> <a id="660" class="Symbol">:</a> <a id="662" href="Relation.Unary.html#3359" class="Function">∀[</a> <a id="665" href="Text.Parser.Types.html#564" class="Record">Parser</a> <a id="672" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="674" href="SExp.html#177" class="Datatype">SExp</a> <a id="679" href="Level.Bounded.html#1072" class="Function Operator">]</a> <a id="681" href="Relation.Unary.html#3359" class="Function">]</a>
  <a id="685" href="SExp.html#655" class="Function">sexp</a> <a id="690" class="Symbol">=</a>
    <a id="696" class="Comment">-- SExp is an inductive type so we build the parser as a fixpoint</a>
    <a id="766" href="Induction.Nat.Strong.html#1188" class="Function">fix</a> <a id="770" class="Symbol">(</a><a id="771" href="Text.Parser.Types.html#564" class="Record">Parser</a> <a id="778" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="780" href="SExp.html#177" class="Datatype">SExp</a> <a id="785" href="Level.Bounded.html#1072" class="Function Operator">]</a><a id="786" class="Symbol">)</a> <a id="788" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="790" class="Symbol">λ</a> <a id="792" href="SExp.html#792" class="Bound">rec</a> <a id="796" class="Symbol">→</a>
        <a id="806" class="Comment">-- First we have atoms. Assuming we have already consumed the leading space, an</a>
        <a id="894" class="Comment">-- atom is just a non empty list of alphabetical characters.</a>

        <a id="964" class="Comment">-- We use `&lt;$&gt;` to turn that back into a string and apply the `Atom` constructor.</a>
    <a id="1050" class="Keyword">let</a> <a id="1054" href="SExp.html#1054" class="Bound">atom</a> <a id="1059" class="Symbol">=</a> <a id="1061" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="1066" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="1068" href="Data.String.Base.html#1623" class="Primitive">String.fromList</a> <a id="1084" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="1086" href="Data.List.NonEmpty.html#1760" class="Function">List⁺.toList</a>
               <a id="1114" href="Text.Parser.Combinators.html#3101" class="Function Operator">&lt;$&gt;</a> <a id="1118" href="Text.Parser.Combinators.html#9287" class="Function">list⁺</a> <a id="1124" href="Text.Parser.Combinators.Char.html#2243" class="Function">alpha</a>

        <a id="1139" class="Comment">-- Then we have subexpressions. Here we have to be a bit careful: we can have both</a>
        <a id="1230" class="Comment">-- * a sexp with additional parentheses à la `(e)`</a>
        <a id="1289" class="Comment">-- * pairing constructs à la `(e f)`</a>

        <a id="1335" class="Comment">-- In both cases they are surrounded by parentheses so we use `parens` and then we</a>
        <a id="1426" class="Comment">-- 1. unconditionally parse a subexpression thanks to `rec` introduced by the fixpoint earlier</a>
        <a id="1529" class="Comment">-- 2. _potentially_ consume a second subexpression (the `?`-tagged combinators are variants</a>
        <a id="1629" class="Comment">--    that are allowed to fail on the side the question mark is on).</a>

        <a id="1707" class="Comment">-- I give a bit more details about `lift` and `box` below.</a>
        <a id="1774" class="Comment">-- As for the previous case we use `&lt;$&gt;` to massage the result into a `SExp`.</a>
        <a id="1860" href="SExp.html#1860" class="Bound">sexp</a> <a id="1865" class="Symbol">=</a> <a id="1867" class="Symbol">(λ</a> <a id="1870" class="Symbol">(</a><a id="1871" href="SExp.html#1871" class="Bound">a</a> <a id="1873" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1875" href="SExp.html#1875" class="Bound">mb</a><a id="1877" class="Symbol">)</a> <a id="1879" class="Symbol">→</a> <a id="1881" href="Data.Maybe.Base.html#1381" class="Function">maybe</a> <a id="1887" class="Symbol">(</a><a id="1888" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="1893" href="SExp.html#1871" class="Bound">a</a><a id="1894" class="Symbol">)</a> <a id="1896" href="SExp.html#1871" class="Bound">a</a> <a id="1898" href="SExp.html#1875" class="Bound">mb</a><a id="1900" class="Symbol">)</a>
               <a id="1917" href="Text.Parser.Combinators.html#3101" class="Function Operator">&lt;$&gt;</a> <a id="1921" href="Text.Parser.Combinators.Char.html#1705" class="Function">parens</a> <a id="1928" class="Symbol">(</a><a id="1929" href="Text.Parser.Combinators.html#2644" class="Function">lift2</a> <a id="1935" class="Symbol">(λ</a> <a id="1938" href="SExp.html#1938" class="Bound">p</a> <a id="1940" href="SExp.html#1940" class="Bound">q</a> <a id="1942" class="Symbol">→</a> <a id="1944" class="Symbol">(</a><a id="1945" href="Text.Parser.Combinators.Char.html#1406" class="Function">spaces</a> <a id="1952" href="Text.Parser.Combinators.html#6065" class="Function Operator">?&amp;&gt;</a> <a id="1956" href="SExp.html#1938" class="Bound">p</a> <a id="1958" href="Text.Parser.Combinators.html#5550" class="Function Operator">&lt;&amp;?</a> <a id="1962" href="Text.Parser.Combinators.html#2357" class="Function">box</a> <a id="1966" href="Text.Parser.Combinators.Char.html#1406" class="Function">spaces</a><a id="1972" class="Symbol">)</a> <a id="1974" href="Text.Parser.Combinators.html#5459" class="Function Operator">&lt;&amp;?&gt;</a> <a id="1979" href="Text.Parser.Combinators.html#2357" class="Function">box</a> <a id="1983" class="Symbol">(</a><a id="1984" href="SExp.html#1940" class="Bound">q</a> <a id="1986" href="Text.Parser.Combinators.html#5550" class="Function Operator">&lt;&amp;?</a> <a id="1990" href="Text.Parser.Combinators.html#2357" class="Function">box</a> <a id="1994" href="Text.Parser.Combinators.Char.html#1406" class="Function">spaces</a><a id="2000" class="Symbol">))</a>
                                 <a id="2036" href="SExp.html#792" class="Bound">rec</a>
                                 <a id="2073" href="SExp.html#792" class="Bound">rec</a><a id="2076" class="Symbol">)</a>
     <a id="2083" class="Keyword">in</a>

     <a id="2092" class="Comment">-- Finally we can put the two things together by using a simple disjunction</a>
     <a id="2173" href="SExp.html#1054" class="Bound">atom</a> <a id="2178" href="Text.Parser.Combinators.html#2489" class="Function Operator">&lt;|&gt;</a> <a id="2182" href="SExp.html#1860" class="Bound">sexp</a>


        <a id="2197" class="Comment">-- `lift`:</a>
        <a id="2216" class="Comment">-- parens is guaranteed to consume some of its input before calling its argument so</a>
        <a id="2308" class="Comment">-- the argument is guarded. We are however not making a direct call to `rec` in a guarded</a>
        <a id="2406" class="Comment">-- position: we are taking a (potentially failing) pairing of two sub-parsers, potentially</a>
        <a id="2505" class="Comment">-- eating some space, etc. So we use `lift2` as a way to distribute the proof that we are in</a>
        <a id="2606" class="Comment">-- a guarded position to the key elements that need it.</a>

        <a id="2671" class="Comment">-- `box`:</a>
        <a id="2689" class="Comment">-- sometimes on the other hand we have a guarded call but do not actually care. We can use</a>
        <a id="2788" class="Comment">-- `box` to discard the proof and use a normal parser in that guarded position.</a>


  <a id="2872" class="Comment">-- The full parser is obtained by disregarding spaces before &amp; after the expression</a>
  <a id="2958" href="SExp.html#2958" class="Function">SEXP</a> <a id="2963" class="Symbol">:</a> <a id="2965" href="Relation.Unary.html#3359" class="Function">∀[</a> <a id="2968" href="Text.Parser.Types.html#564" class="Record">Parser</a> <a id="2975" href="Level.Bounded.html#1072" class="Function Operator">[</a> <a id="2977" href="SExp.html#177" class="Datatype">SExp</a> <a id="2982" href="Level.Bounded.html#1072" class="Function Operator">]</a> <a id="2984" href="Relation.Unary.html#3359" class="Function">]</a>
  <a id="2988" href="SExp.html#2958" class="Function">SEXP</a> <a id="2993" class="Symbol">=</a> <a id="2995" href="Text.Parser.Combinators.Char.html#1406" class="Function">spaces</a> <a id="3002" href="Text.Parser.Combinators.html#6065" class="Function Operator">?&amp;&gt;</a> <a id="3006" href="SExp.html#655" class="Function">sexp</a> <a id="3011" href="Text.Parser.Combinators.html#5550" class="Function Operator">&lt;&amp;?</a> <a id="3015" href="Text.Parser.Combinators.html#2357" class="Function">box</a> <a id="3019" href="Text.Parser.Combinators.Char.html#1406" class="Function">spaces</a>

<a id="3027" class="Keyword">open</a> <a id="3032" class="Keyword">import</a> <a id="3039" href="Base.html" class="Module">Base</a> <a id="3044" href="Level.html#360" class="Primitive">Level.zero</a>

<a id="3056" class="Comment">-- And we can run the thing on a test (which is very convenient when refactoring grammars!..):</a>
<a id="3151" href="SExp.html#3151" class="Function">_</a> <a id="3153" class="Symbol">:</a> <a id="3155" class="String">&quot;((  this    is)
      ((a (  pair based))
          ((S)(expression  ))))   &quot;</a> <a id="3234" href="Base.html#3339" class="Function Operator">∈</a> <a id="3236" href="SExp.html#2958" class="Function">SEXP</a>
<a id="3241" class="Symbol">_</a> <a id="3243" class="Symbol">=</a> <a id="3245" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3250" class="Symbol">(</a><a id="3251" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3256" class="Symbol">(</a><a id="3257" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3262" class="String">&quot;this&quot;</a><a id="3268" class="Symbol">)</a> <a id="3270" class="Symbol">(</a><a id="3271" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3276" class="String">&quot;is&quot;</a><a id="3280" class="Symbol">))</a>
         <a id="3292" class="Symbol">(</a><a id="3293" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3298" class="Symbol">(</a><a id="3299" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3304" class="Symbol">(</a><a id="3305" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3310" class="String">&quot;a&quot;</a><a id="3313" class="Symbol">)</a>
                     <a id="3336" class="Symbol">(</a><a id="3337" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3342" class="Symbol">(</a><a id="3343" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3348" class="String">&quot;pair&quot;</a><a id="3354" class="Symbol">)</a> <a id="3356" class="Symbol">(</a><a id="3357" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3362" class="String">&quot;based&quot;</a><a id="3369" class="Symbol">)))</a>
                <a id="3389" class="Symbol">(</a><a id="3390" href="SExp.html#219" class="InductiveConstructor">Pair</a> <a id="3395" class="Symbol">(</a><a id="3396" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3401" class="String">&quot;S&quot;</a><a id="3404" class="Symbol">)</a>
                      <a id="3428" class="Symbol">(</a><a id="3429" href="SExp.html#196" class="InductiveConstructor">Atom</a> <a id="3434" class="String">&quot;expression&quot;</a><a id="3446" class="Symbol">)))</a> <a id="3450" href="Base.html#1550" class="InductiveConstructor Operator">!</a>
</pre></body></html>